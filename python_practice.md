# Python Practice

## 四則演算

```py
a = 7
b = 10
c = a + b
print (a ,b ,c)

#cには 7+10 合計が表示されます
>>7 10 17

// 小数点切り捨て 

/  通常の割り算

a = 7
b = 10
#aという名前の変数に 7を代入,bに10を代入

b = 22
#この場合変数は上書きされます

a = int(input() )
print (a)
```
inputは入力を受け付ける。
intは整数を表す。なので文字列(str)を送るとエラー。

```py
# 型を確認するにはtype(hoge)で表示。
<class 'int'> or <class 'str'> 

# 浮動小数点（実数）で表示したい場合はfloatを使う
float(hoge)

a = 10**100
１０の１００乗をaに代入する。
```

### []を使った文字の抽出
```py
 p='beatmaniaIIDX'

 print(p[0])#先頭から０+1番目
>>>b
 print(p[-1])#末尾から１番目
>>>X
 print(p[10])#先頭から１０+1番目
>>>I
 print(p[-5])#末尾から５番目
>>>a
#前と末尾で数え方が違うところに注意。
```

### 変数を置き換える
```py
newname = name.replace('a','i')
newname

#新しく変数を作り、文字列関数(.replace)を使って置き換える。

.upper() #すべて大文字にする

.lower() #すべて小文字にする

#抽出関数を使って必要な文字列のあとに付けると必要な部分のみ大文字／小文字にできる

 p.replace(p[9:],p[9:].upper())

 p.replace(p[9:],p[9:].lower())
```
## スライス

### 文字列から任意の文字を取り出す

```py
p = "beatmaniaIIDX"
p[:] # 最初から最後まで
p[0:5] 0番目から５-1番目まで
'beatm'
p[5:-2] # 5番目から末尾から数えて２-1番目の間
'aniaII'
p[-8:-4] #末尾8から末尾4文字目まで
'ania'
p[::2] # ２-1文字ごとに0番目から末尾0番目まで
'bamnaIX'
p[:2:-1] # 逆順にする(負数ステップサイズ)
'XDIIainamt'
```

## シーケンス

連続したデータ、複数の値を順番に並べたものをひとかたまりとして扱う要素をシーケンス型と呼ぶ。
```py
result = [97,64,87,77,86,]
```

## リスト作成
リストは大括弧［］で記述します
```py
# 空欄配列の作成

empty=[]

# 配列に文字列を代入する
empty = list('東京臨海新交通臨海線')

list('東京臨海新交通臨海線')
['東', '京', '臨', '海', '新', '交', '通', '臨', '海', '線'] # 文字列一文字ずつリストを作る。文字列のチェック等によく使われる。
```

## タプルの作成
リストに対しカッコで記述する
```py
empty2=()
empty2=('aa','bb','cc')
# or
empty2=(list('abcdefg'))
```

### タプルとリストの違い

**リストは変更ができる（ミュータブル）が、タプルは変更ができない（イミュータブル）** 。文字列の表示などは可能。
プログラム中で変更されることを望まない場合に使う

定義した後、追加削除変更は不可能。Insert,apeend等の関数はない。

### リストをタプルへ変換
```py
k_list =['新橋','汐留','竹芝','日の出','芝浦']
t_tuple=tuple(k_list)
#  ↓
('新橋', '汐留', '竹芝', '日の出', '芝浦')

また、タプルからリストへ変換するには
l_turple=list(t_turple)
```
### リストを分割する
```py
# .splitで分割する
dd='2020/07/24'

dd.split('/')   # ／を基に分割してリストを作成する
['2020', '07', '24']
```
### 挿入と削除
```py
# 挿入

hogelist.append('HOGE')      リストの末尾に文字列を追加する

        .extend(HOGE)    リストの末尾に別のリストを追加する

        .insert(2,'OOHH')    2(+1)番目に OOHHを追加する

# 削除

del hogelist[2]      del文を使って削除する。()は使わない

        .remove('文字列')     要素を指定する場合はremoveを使う

        .pop(2)      1(+1)番要素を取り出して削除。特に指定しない場合は末尾(-1)が指定される
```

####  リスト情報取得
```py
 # オフセット位置を表示させる
hogelist.index('新橋')
>> 4

# 値があるか調べる
'竹芝' in hogelist  
>> True
# 値がないことを調べる
'汐留' not in hogelist
>> false

# 個数の計算
q = list('aaabcccdddddeeeee')
q.count('d')
>> 5

# 要素の個数を調べる
hoge=['新橋', '汐留', '竹芝', '日の出', '芝浦', '有明', 'お台場']
len(hoge)
>> 7
```

### 並び替え
```py
q.sort(hogelist)

  # sorted関数は基のリストに影響を与えない
    print(sorted(hogelist))

  # 降順で並び替えるには
  q.sort(reverse=True)

```

### リストのリスト

**ネスト** と呼びます。
```py
sla =['T', 'O', 'K', 'Y', 'O', 'G', 'I', 'R', 'L']
slb =['P', 'U', 'R', 'F', 'U', 'M', 'E']
slc = [sla,slb]

[['T', 'O', 'K', 'Y', 'O', 'G', 'I', 'R', 'L'], ['P', 'U', 'R', 'F', 'U', 'M', 'E']]

# sla0個目3(+1)番目の値を取り出してみます
print slc[0][3]
>> Y
```

## ディクショナリ（辞書）

検索・照合などで活躍するデータ型

* 他言語でいうところの連想配列・ハッシュなどと同じ？

* 順序の概念が無い。要素を選択する時オフセットは使わない

  値にキーを付与して使う。

* 辞書はイミュータブルなので後から追加削除変更が可能


### 辞書の作成
```py
#dict =  { key : value}
ydict = {'新宿':1300,'代々木':700,'原宿':1500}

#dict()でも作成する場合は

  #リストの場合　　大かっこ
    xdict = [['新宿',1300],['代々木',700],['原宿',1500]]
    dict(xdict)
  #タプルの場合　　大かっこの中に中カッコ
    ddict = [('新宿',1300),('代々木',700),('原宿',1500)]
    dict(ddict)
```

### 要素の追加と変更

```py
ydict['六本木'] = 5000
# 存在しないキーを指定すると新たに要素を追加

ydict['新宿'] = 1100
# すでに存在するキーを指定すると値が上書きされる
```

### キーを基に要素を取得
.getメソッドを使うかキーをそのまま指定するやり方

キー定義が無かった場合GETメソッドはNoneを返すが、キー指定はエラーが返される
```py
# GET()  「代々木」をキーにして値を取得します
all_m.get('代々木')
>> 700

#   もし、キーが無い場合に「いません」を出力
all_m.get('有楽町','いません')

#   こちらはキーを指定するやり方
all_m['代々木']
>> 700
```

### 各値の要素を取得してfor等でループ処理する

* keys( ): 各要素のキーkeyに対してforループ処理
* values( ): 各要素の値valueに対して　〃
* items( ): 各要素のキーkeyと値valueに対して　〃
```py
ydict.keys()
  dict_keys(['新宿','代々木','原宿'])

ydict.values()
  dict_values(['1300','700','1500'])

ydict.items()
  dict_items([('新宿',1300)('代々木',700)('原宿',1500)])

# for文ですべて取得する
for dics in ydict.values:
    print(dicts)

1300
700
1500
```
### ディクショナリ同士の連結
```py
all_m = {'hoge':200}
ad = {'hogo':2000}

# 連結元.update(連結するディクショナリ)
all_m.update(ad)

# 同じキー要素があった場合上書きになるので注意
a.update({"Mickey":1000,"Mackey":1500})
```

---
# クラスとインスタンス

## クラス

```py
import random

 class Fukubiki:	#クラス宣言。先頭の文字は大文字
    def garagara(self):
    	#メソッド名の宣言。(他言語のthisみたいなもの)
		return random.randint(1,10)
    	#メソッドが呼ばれた時にrandom.randintの結果を返す(return)
	
atare = Fukubiki()	Fukubikiを実体化（インスタンス化）
print(atare.garagara() )	atare内garagaraを呼び出して出力
```

* セルフ(self)とは？

クラスのインスタンス自分自身を表すもの。省略できないため必ず指定する。


## コンストラクタ

オブジェクトが呼び出されたら即時に実行される関数。

__init__を付けて初期化するときなどによく使われます。

```py
class pocketnamonster:
    def __init__(self,name='nanasi'): # 第二引数にnameが入らない場合の文字列を追加しています。
        self.name = name

    def print_name(self):
        print('このポケットなモンスターは{}です'.format(self.name))

dare=pocketnamonster('Pikachu') # 変数dareをインスタンス（実体化）化してプログラム内で使えるようにします。この際引数にPikachuを代入します。

dare.print_name()   # print_name を呼び出して出力します。

>> 出力結果：このポケットなモンスターはPikachuです
```
